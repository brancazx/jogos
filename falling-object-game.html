<!-- Indica ao navegador que este √© um documento HTML5 -->
<!doctype html>
<!-- Come√ßo do documento HTML e definindo idioma como portugu√™s do Brasil -->
<html lang="pt-BR">
<head>
  <!-- Define o conjunto de caracteres como UTF-8 para suportar acentua√ß√£o -->
  <meta charset="utf-8">
  <!-- Define viewport para responsividade em dispositivos m√≥veis -->
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <!-- T√≠tulo da aba do navegador -->
  <title>Falling Object Game - Exemplo</title>
  <style>
    /* === ESTILOS CSS DO JOGO === */

    /* Remove margens padr√£o do body e define fontes e background gradiente */
    body {
      margin: 0; /* Remove margens padr√£o */
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; /* Fonte geral */
      background: linear-gradient(180deg,#121212 0%, #1b2735 100%); /* Fundo gradiente escuro */
      color: #fff; /* Cor do texto */
      height: 100vh; /* Ocupa altura inteira da janela */
      display: flex; /* Usando flex para centralizar */
      align-items: center; /* Centralizar verticalmente */
      justify-content: center; /* Centralizar horizontalmente */
    }

    /* Caixa principal do jogo */
    .game-wrap {
      width: 420px; /* Largura fixa */
      max-width: 95vw; /* Em telas pequenas adapta */
      height: 640px; /* Altura fixa */
      background: linear-gradient(180deg,#0f1720,#08101a); /* Fundo gradiente da √°rea de jogo */
      border-radius: 12px; /* Cantos arredondados */
      box-shadow: 0 10px 30px rgba(0,0,0,0.6); /* Sombra ao redor */
      position: relative; /* Necess√°rio para posicionar elementos internos absolutos */
      overflow: hidden; /* Oculta o que ultrapassar */
    }

    /* O canvas ocupa toda √°rea interna */
    canvas {
      width: 100%;
      height: 100%;
      display: block; /* Remove espa√ßo abaixo */
      background: transparent; /* Fundo transparente (j√° definido pelo container) */
    }

    /* Tela inicial sobreposta ao jogo */
    .overlay {
      position: absolute; /* Fica sobre o canvas */
      inset: 0; /* Preenche toda a √°rea */
      display: flex; /* Centraliza conte√∫do */
      flex-direction: column; /* Conte√∫do em coluna */
      align-items: center; /* Centralizar horizontalmente */
      justify-content: center; /* Centralizar verticalmente */
      background: rgba(0,0,0,0.55); /* Fundo semi-transparente */
      gap: 14px; /* Espa√ßo entre elementos */
      padding: 20px; /* Espa√ßo interno */
      text-align: center; /* Texto centralizado */
    }

    /* Bot√µes do jogo */
    .btn {
      appearance: none; /* Remove estilo padr√£o */
      border: none; /* Sem borda */
      padding: 12px 20px; /* Espa√ßamento interno */
      border-radius: 10px; /* Cantos arredondados */
      font-weight: 700; /* Negrito */
      cursor: pointer; /* Cursor de m√£o */
      font-size: 16px; /* Tamanho fonte */
      background: linear-gradient(90deg,#00C9A7,#00E3FF); /* Gradiente no bot√£o */
      color: #021017; /* Cor do texto */
    }

    /* HUD com pontua√ß√£o e vidas */
    .hud {
      position: absolute; /* Sobre o canvas */
      top: 10px; /* Dist√¢ncia do topo */
      left: 10px; /* Margem esquerda */
      right: 10px; /* Margem direita */
      display: flex; /* Itens em linha */
      justify-content: space-between; /* Espa√ßo entre eles */
      align-items: center; /* Alinhamento vertical */
      pointer-events: none; /* N√£o interfere no clique */
      z-index: 5; /* Fica acima do canvas */
    }

    /* Pain√©is de pontua√ß√£o e vidas */
    .panel {
      background: rgba(255,255,255,0.03); /* Fundo semi-transparente */
      padding: 8px 12px; /* Espa√ßamento interno */
      border-radius: 8px; /* Cantos arredondados */
      font-weight: 600; /* Negrito */
      font-size: 14px; /* Tamanho fonte */
      pointer-events: none; /* N√£o clic√°vel */
    }

    /* Tela de Game Over */
    .game-over {
      position: absolute; /* Sobre o canvas */
      inset: 0; /* Preenche toda a √°rea */
      display: none; /* Inicialmente escondida */
      align-items: center; /* Centralizar verticalmente */
      justify-content: center; /* Centralizar horizontalmente */
      background: rgba(0,0,0,0.7); /* Fundo escuro */
      color: #fff; /* Texto branco */
      z-index: 6; /* Acima do HUD */
      flex-direction: column; /* Elementos em coluna */
      gap: 12px; /* Espa√ßamento entre elementos */
    }

    /* Texto auxiliar */
    .hint {
      font-size: 13px; /* Fonte menor */
      color: #cbd5e1; /* Cor cinza clara */
    }

    /* Bot√£o start ativo */
    .start-btn { pointer-events: auto; }
  </style>
</head>
<body>
  <!-- Container principal do jogo -->
  <div class="game-wrap">
    <!-- Tela inicial do jogo com t√≠tulo e bot√£o Start -->
    <div id="startScreen" class="overlay">
      <h1>Falling Object</h1>
      <p>Pegue os objetos que caem com a cesta. Perde vida se deixar cair.</p>
      <!-- Bot√£o para iniciar o jogo -->
      <button id="startButton" class="btn start-btn">Start</button>
      <div class="hint">Use ‚Üê ‚Üí ou A D para mover ‚Äî ou clique / arraste</div>
    </div>

    <!-- HUD exibindo pontua√ß√£o e vidas -->
    <div class="hud">
      <div id="scorePanel" class="panel">Pontua√ß√£o: <span id="score">0</span></div>
      <div id="livesPanel" class="panel">Vidas: <span id="lives">3</span></div>
    </div>

    <!-- Canvas do jogo -->
    <canvas id="gameCanvas" width="420" height="640"></canvas>

    <!-- Tela exibida quando o jogo acaba -->
    <div id="gameOverScreen" class="game-over">
      <h2>Game Over</h2>
      <p>Seu placar: <span id="finalScore">0</span></p>
      <!-- Bot√£o para reiniciar -->
      <button id="restartButton" class="btn">Jogar novamente</button>
    </div>
  </div>

 <script>
  // === Seleciona elementos HTML do DOM ===
  const canvas = document.getElementById('gameCanvas'); // Canvas onde o jogo √© desenhado
  const ctx = canvas.getContext('2d'); // Contexto 2D para desenhar no canvas
  const startScreen = document.getElementById('startScreen'); // Tela inicial
  const startButton = document.getElementById('startButton'); // Bot√£o Start
  const gameOverScreen = document.getElementById('gameOverScreen'); // Tela de Game Over
  const restartButton = document.getElementById('restartButton'); // Bot√£o para reiniciar
  const scoreEl = document.getElementById('score'); // Elemento que mostra a pontua√ß√£o
  const livesEl = document.getElementById('lives'); // Elemento que mostra as vidas
  const finalScoreEl = document.getElementById('finalScore'); // Elemento que mostra pontua√ß√£o final

  // === √Åudios do jogo ===
  const coinSound = new Audio("coin.mp3"); // Som ao pegar moeda
  const loseLifeSound = new Audio("lose.mp3"); // Som ao perder vida
  coinSound.volume = 0.7; // Volume moeda
  loseLifeSound.volume = 0.8; // Volume perder vida

  // === Vari√°veis de estado do jogo ===
  let width = canvas.width;  // Largura do canvas
  let height = canvas.height; // Altura do canvas
  let player = null; // Objeto do jogador
  let fallingObjects = []; // Lista de objetos que caem
  let keys = {}; // Armazena teclas pressionadas
  let mouseDown = false; // Se mouse est√° pressionado
  let lastTime = 0; // Guarda o √∫ltimo timestamp para calcular dt
  let spawnTimer = 0; // Contador para spawn de objetos
  let spawnInterval = 900; // Intervalo inicial para spawn (ms)
  let score = 0; // Pontua√ß√£o
  let lives = 3; // Vidas atuais
  const maxLives = 3; // M√°ximo de vidas
  let isRunning = false; // Estado do jogo rodando ou n√£o

  // === Par√¢metros de dificuldade ===
  const baseFallSpeed = 120; // Velocidade base dos objetos caindo
  const difficultyIncreaseRate = 0.02; // A cada ponto, aumenta dificuldade

  // === Fun√ß√£o para inicializar o jogo ===
  function initGame() {
    // Cria objeto do jogador com posi√ß√£o, tamanho e velocidade
    player = {
      w: 90, // largura
      h: 20, // altura
      x: width/2 - 45, // posi√ß√£o X centralizada
      y: height - 60, // posi√ß√£o Y pr√≥ximo ao ch√£o
      speed: 450 // velocidade
    };
    fallingObjects = []; // limpa lista de objetos
    spawnTimer = 0; // zera o timer
    score = 0; // zera pontua√ß√£o
    lives = maxLives; // reseta vidas
    // Atualiza HUD
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    // Esconde telas iniciais e game over
    gameOverScreen.style.display = 'none';
    startScreen.style.display = 'none';
  }

  // === Fun√ß√£o para come√ßar o jogo ===
  function startGame() {
    initGame(); // reseta tudo
    isRunning = true; // marca que est√° rodando
    lastTime = performance.now(); // registra tempo inicial
    requestAnimationFrame(gameLoop); // inicia loop do jogo
  }

  // === Fun√ß√£o para terminar o jogo ===
  function endGame() {
    isRunning = false; // para loop
    finalScoreEl.textContent = score; // mostra pontua√ß√£o final
    gameOverScreen.style.display = 'flex'; // mostra tela game over
  }

  // === Cria um objeto caindo ===
  function spawnObject() {
    const size = 18 + Math.random() * 26; // tamanho aleat√≥rio
    const x = Math.random() * (width - size); // posi√ß√£o X aleat√≥ria
    // velocidade baseada no score
    const speed = baseFallSpeed + score * difficultyIncreaseRate * 100;
    // adiciona objeto na lista
    fallingObjects.push({ x, y: -size, size, speed });
  }

  // === Atualiza a l√≥gica do jogo a cada frame ===
  function update(dt) {
    // --- Movimento do jogador ---
    if (keys['ArrowLeft'] || keys['a'] || keys['A']) player.x -= player.speed * dt; // esquerda
    if (keys['ArrowRight'] || keys['d'] || keys['D']) player.x += player.speed * dt; // direita
    // Limita movimento para n√£o sair da tela
    if (player.x < 0) player.x = 0;
    if (player.x + player.w > width) player.x = width - player.w;

    // --- Atualiza objetos caindo ---
    for (let i = fallingObjects.length - 1; i >= 0; i--) {
      const obj = fallingObjects[i]; // pega objeto
      obj.y += obj.speed * dt; // move para baixo

      // Checa colis√£o com o jogador (pegou moeda)
      if (
        obj.y + obj.size >= player.y && 
        obj.x < player.x + player.w && 
        obj.x + obj.size > player.x && 
        obj.y < player.y + player.h
      ) {
        // Se colidiu: soma pontos e remove objeto
        score += 10;
        scoreEl.textContent = score;
        fallingObjects.splice(i, 1);

        // üîä toca som da moeda
        coinSound.currentTime = 0;
        coinSound.play();

        continue; // pula para o pr√≥ximo objeto
      }

      // Se o objeto passou do ch√£o: perde vida
      if (obj.y > height + 60) {
        fallingObjects.splice(i, 1); // remove objeto
        lives -= 1; // perde vida
        livesEl.textContent = lives; // atualiza HUD

        // üîä toca som de perder vida
        loseLifeSound.currentTime = 0;
        loseLifeSound.play();

        if (lives <= 0) { // se vidas acabaram, game over
          endGame();
          return; // sai da fun√ß√£o
        }
      }
    }

    // --- Controle de spawn ---
    spawnTimer += dt * 1000; // incrementa timer em ms
    const adjustedInterval = Math.max(300, spawnInterval - score * 2); // intervalo diminui conforme score
    if (spawnTimer > adjustedInterval) { // se passou do intervalo, cria objeto
      spawnTimer = 0;
      spawnObject();
    }
  }

  // === Fun√ß√£o para desenhar os elementos na tela ===
  function draw() {
    ctx.clearRect(0, 0, width, height); // limpa tela

    // Desenha jogador (ret√¢ngulo arredondado)
    ctx.fillStyle = '#00E3FF';
    roundRect(ctx, player.x, player.y, player.w, player.h, 6, true, false);

    // Sombra embaixo do jogador
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(player.x + 8, player.y + player.h + 2, player.w - 16, 4);

    // Desenha cada objeto caindo (bolinha)
    for (const obj of fallingObjects) {
      ctx.beginPath();
      ctx.fillStyle = '#FFD166';
      ctx.arc(obj.x + obj.size/2, obj.y + obj.size/2, obj.size/2, 0, Math.PI * 2);
      ctx.fill();
      ctx.closePath();
    }
  }

  // === Fun√ß√£o para desenhar ret√¢ngulo arredondado ===
  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof r === 'undefined') r = 5;
    if (typeof fill === 'undefined') fill = true;
    if (typeof stroke === 'undefined') stroke = false;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // === Loop principal do jogo ===
  function gameLoop(timestamp) {
    if (!isRunning) return; // se n√£o est√° rodando, sai
    const dt = (timestamp - lastTime) / 1000; // calcula delta time em segundos
    lastTime = timestamp; // atualiza √∫ltimo tempo
    update(dt); // atualiza l√≥gica do jogo
    draw(); // desenha na tela
    requestAnimationFrame(gameLoop); // chama pr√≥ximo frame
  }

  // === Controles de teclado ===
  window.addEventListener('keydown', e => { keys[e.key] = true; }); // quando tecla pressionada
  window.addEventListener('keyup', e => { keys[e.key] = false; }); // quando tecla solta

  // === Controles de mouse e toque (para dispositivos m√≥veis) ===
  canvas.addEventListener('mousedown', e => { mouseDown = true; movePlayerToPointer(e); }); // clique inicial
  canvas.addEventListener('mousemove', e => { if (mouseDown) movePlayerToPointer(e); }); // arrastar
  window.addEventListener('mouseup', () => { mouseDown = false; }); // soltar mouse

  canvas.addEventListener('touchstart', e => { mouseDown = true; movePlayerToPointer(e.touches[0]); e.preventDefault(); }); // toque inicial
  canvas.addEventListener('touchmove', e => { if (mouseDown) movePlayerToPointer(e.touches[0]); e.preventDefault(); }); // arrastar toque
  canvas.addEventListener('touchend', () => { mouseDown = false; }); // soltar toque

  // === Fun√ß√£o para mover player conforme posi√ß√£o do mouse ou dedo ===
  function movePlayerToPointer(e) {
    const rect = canvas.getBoundingClientRect(); // pega posi√ß√£o do canvas na tela
    const x = (e.clientX - rect.left) * (canvas.width / rect.width); // calcula posi√ß√£o relativa
    player.x = x - player.w/2; // centraliza player no ponto
    // limita player para n√£o sair da tela
    if (player.x < 0) player.x = 0;
    if (player.x + player.w > width) player.x = width - player.w;
  }

  // === Liga bot√µes Start e Restart ===
  startButton.addEventListener('click', () => { startGame(); }); // inicia jogo ao clicar Start
  restartButton.addEventListener('click', () => { startGame(); }); // reinicia jogo ao clicar Restart

  // === Ajusta tamanho do canvas (mant√©m fixo) ===
  function resizeCanvas() {
    width = canvas.width = 420;
    height = canvas.height = 640;
  }
  window.addEventListener('resize', resizeCanvas); // atualiza ao redimensionar janela
  resizeCanvas(); // chama uma vez no in√≠cio

  // === Permite iniciar jogo com tecla Enter ===
  window.addEventListener('keydown', e => {
    if (e.key === 'Enter' && startScreen.style.display !== 'none') {
      startGame();
    }
  });

  // === Mostra tela inicial quando abre p√°gina ===
  startScreen.style.display = 'flex';
</script>

    
</body>
</html>
