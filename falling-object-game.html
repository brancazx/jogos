<!doctype html>
<html lang="pt-BR">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>GUN-Nac Style ‚Äî Hard & HUD (com dificuldades)</title>
    <style>
        /* ------------------------------
           ESTILO GERAL & VARI√ÅVEIS
           ------------------------------ */
        :root {
            --bg: #071020;
            --accent: #6ee7b7;
            --muted: #9fb3c8;
            --danger: #ff6b6b;
            --gold: #ffd86b;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: linear-gradient(180deg, #021228 0%, #071020 60%);
            font-family: Inter, system-ui, Arial, sans-serif;
            color: #dfeef7;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* ------------------------------
           HUD (compacto e embaixo)
           ------------------------------ */
        #ui {
            position: fixed;
            left: 10px;
            bottom: 10px; /* <- HUD fixado embaixo */
            z-index: 30;
            background: rgba(0, 0, 0, 0.36);
            padding: 6px 8px; /* compacto */
            border-radius: 8px;
            backdrop-filter: blur(6px);
            font-weight: 600;
            font-size: 11px; /* um pouco menor */
            line-height: 1.25;
            min-width: 120px;
            color: #dfeef7;
        }

        .bar {
            height: 6px;
            border-radius: 4px;
            overflow: hidden;
            background: #1b2430;
            margin-top: 4px;
            width: 110px; /* menor que antes */
            box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.4)
        }

        .bar span {
            display: block;
            height: 100%
        }

        #ui .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 6px
        }

        #hudSmall {
            font-size: 10px;
            color: var(--muted);
            margin-top: 4px
        }

        /* Menu / bot√µes (mantive praticamente como estava) */
        #menu {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 40;
            background: rgba(0, 0, 0, 0.66);
            flex-direction: column;
            color: #dfeef7;
            text-align: center;
            padding: 18px
        }

        #menu button {
            margin-top: 12px;
            padding: 10px 16px;
            border-radius: 8px;
            border: none;
            background: var(--accent);
            color: #042;
            cursor: pointer;
            font-weight: 800;
            letter-spacing: 0.6px
        }

        #menu .diffBtns {
            display: flex;
            gap: 10px;
            margin-top: 12px
        }

        footer {
            position: fixed;
            left: 50%;
            bottom: 10px;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.32);
            font-size: 12px
        }

        .diff {
            background: var(--gold) !important;
            color: #000 !important;
            padding: 8px 12px;
            border-radius: 8px
        }

        .startBtn {
            background: var(--accent) !important
        }

        /* ‚ö† Aviso do Boss */
        #bossWarning {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: bold;
            color: #ff4040;
            text-shadow: 0 0 10px #000;
            display: none;
            animation: blink 0.5s infinite alternate;
            z-index: 1000;
        }

        @keyframes blink {
            from {
                opacity: 1;
            }

            to {
                opacity: 0.2;
            }
        }

        /* MENU DE PAUSA */
        #pauseMenu {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 45;
            background: rgba(0, 0, 0, 0.66);
            flex-direction: column;
            color: #dfeef7;
            text-align: center;
            padding: 18px;
        }

        #pauseMenu button {
            margin: 8px;
            padding: 10px 14px;
            border-radius: 8px;
            border: none;
            background: var(--accent);
            color: #042;
            cursor: pointer;
            font-weight: 800;
        }

        /* Mensagem grande de vit√≥ria (opcional) */
        #victoryMsg {
            position: fixed;
            inset: 0;
            display: none;
            z-index: 1200;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }
        #victoryMsg .box {
            background: rgba(0,0,0,0.6);
            padding: 24px 36px;
            border-radius: 12px;
            font-size: 28px;
            color: #ffd86b;
            text-shadow: 0 6px 20px rgba(0,0,0,0.6);
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>

    <!-- HUD DOM (agora embaixo, compacto) -->
    <div id="ui" aria-live="polite">
        <div class="row">
            <div>Score</div>
            <div id="score">0</div>
        </div>
        <div class="row">
            <div>N√≠vel</div>
            <div id="level">1</div>
        </div>

        <div style="margin-top:6px">Vidas: <strong id="lives">3</strong>
            <div class="bar"><span id="lifeBar" style="width:100%;background:var(--accent)"></span></div>
        </div>

        <div style="margin-top:6px">Power: <strong id="power">1</strong>
            <div class="bar"><span id="powerBar" style="width:16%;background:var(--gold)"></span></div>
        </div>

        <div id="hudSmall">WASD / Setas ‚Äî mover ¬∑ Espa√ßo ‚Äî atirar ¬∑ P ‚Äî pausar</div>
    </div>

    <!-- ‚ö† Aviso de Boss -->
    <div id="bossWarning">‚ö† UM BOSS SE APROXIMA!</div>

    <div id="menu">
        <h1 style="margin:0 0 6px 0;font-size:28px">üöÄ GUN-Nac Style</h1>
        <p style="margin:0 0 8px 0;color:var(--muted)">Escolha sua dificuldade</p>

        <!-- Bot√µes de dificuldade -->
        <div id="difficultyRow" class="diffBtns" style="margin-bottom:10px">
            <button class="diff" data-diff="easy">F√°cil</button>
            <button class="diff" data-diff="medium">M√©dio</button>
            <button class="diff" data-diff="hard">Dif√≠cil</button>
        </div>

        <button id="startBtn" class="startBtn">Come√ßar</button>
        <small style="margin-top:8px;color:var(--muted)">Clique na dificuldade desejada e depois em Come√ßar ‚Äî Ou
            pressione Enter (M√©dio)</small>
    </div>

    <!-- PAUSE MENU -->
    <div id="pauseMenu">
        <h1 style="margin:0 0 6px 0;font-size:28px">|| Pausado</h1>
        <div>
            <button id="continueBtn">Continuar</button>
            <button id="restartBtn">Reiniciar</button>
            <button id="mainMenuBtn">Menu Principal</button>
        </div>
    </div>

    <!-- victory message (opcional) -->
    <div id="victoryMsg">
        <div class="box">üèÜ CHEFE DERROTADO! üèÜ</div>
    </div>

    <footer>Feito com ‚ù§ ‚Äî c√≥digo refatorado</footer>
    <script>
        (function () {
            /* =========================
               Setup inicial e resize
               ========================= */
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            function resize() {
                canvas.width = innerWidth;
                canvas.height = innerHeight;
            }
            addEventListener('resize', resize);
            resize();

            /* =========================
               Elementos UI (DOM)
               ========================= */
            const uiScore = document.getElementById('score');
            const uiLives = document.getElementById('lives');
            const uiPower = document.getElementById('power');
            const uiLevel = document.getElementById('level');
            const lifeBar = document.getElementById('lifeBar');
            const powerBar = document.getElementById('powerBar');
            const menu = document.getElementById('menu');
            const startBtn = document.getElementById('startBtn');
            const diffButtons = document.querySelectorAll('.diff');
            const bossWarning = document.getElementById('bossWarning'); // ‚ö† elemento de aviso
            const hudEl = document.getElementById('ui'); // elemento HUD (usado para calcular √°rea reservada)
            const pauseMenu = document.getElementById('pauseMenu');
            const continueBtn = document.getElementById('continueBtn');
            const restartBtn = document.getElementById('restartBtn');
            const mainMenuBtn = document.getElementById('mainMenuBtn');
            const victoryMsg = document.getElementById('victoryMsg');

            // fun√ß√£o utilit√°ria para obter a "altura" reservada pelo HUD
            function getHudHeight() {
                // adicionamos uma pequena folga (margin) para evitar overlap gr√°fico
                return (hudEl ? hudEl.offsetHeight : 72) + 12;
            }

            /* =========================
               Mostrar aviso do boss
               ========================= */
            function showBossWarning() {
                bossWarning.style.display = 'block';
                setTimeout(() => bossWarning.style.display = 'none', 3000);
            }

            /* =========================
               Input
               ========================= */
            const keys = {};
            keys.space = false;
            addEventListener('keydown', e => {
                const k = (e.key || '').toLowerCase();
                keys[k] = true;
                if (e.code === 'Space') keys.space = true;
                if (e.key === 'Enter' && !game.running) {
                    const sel = menu.getAttribute('data-selected-diff') || 'medium';
                    startGame(sel);
                }
                if (e.key && e.key.toLowerCase() === 'p') togglePause();
            });
            addEventListener('keyup', e => {
                const k = (e.key || '').toLowerCase();
                keys[k] = false;
                if (e.code === 'Space') keys.space = false;
            });

            /* =========================
               Entidades / Arrays
               ========================= */
            let bullets = [], enemies = [], enemyBullets = [], powerups = [], particles = [];
            let boss = null;

            // starfield
            const stars = Array.from({ length: 160 }, () => ({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, s: Math.random() * 1.6 + 0.2 }));

            /* =========================
               Dificuldades / Estado
               ========================= */
            const DIFFICULTIES = {
                easy: { enemyHp: 0.65, enemySpeed: 0.85, enemyCount: 0.7, bossHp: 0.7, bossBullets: 0.7, powerRate: 1.35, enemyFireMult: 0.7 },
                medium: { enemyHp: 1.0, enemySpeed: 1.0, enemyCount: 1.0, bossHp: 1.0, bossBullets: 1.0, powerRate: 1.0, enemyFireMult: 1.0 },
                hard: { enemyHp: 1.45, enemySpeed: 1.18, enemyCount: 1.45, bossHp: 1.6, bossBullets: 1.3, powerRate: 0.75, enemyFireMult: 1.25 }
            };

            // adicionei flag para garantir som do boss tocando apenas uma vez
            const game = { running: false, paused: false, score: 0, level: 1, waveTimer: 0, diffKey: 'medium', diff: DIFFICULTIES.medium, nextBossScore: 10000, bossDefeatedPlayed: false };

            /* =========================
               √Åudio (mantive nomes originais)
               ========================= */
            let audioCtx = null;
            try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) { audioCtx = null; }
            const bgMusic = new Audio("fundao.mp3");
            bgMusic.loop = true;
            const enemyDeathSfx = new Audio("morte dos inimigos.mp3");
            const playerDeathSfx = new Audio("morte dos inimigos.mp3");
            // som de vit√≥ria do boss (adicione esse arquivo na pasta do jogo)
            const bossDefeatedSfx = new Audio("boss-defeated.mp3");
            try { bossDefeatedSfx.preload = 'auto'; } catch (e) { }

            function startBackgroundMusic() {
                try { bgMusic.currentTime = 0; bgMusic.play(); } catch (e) { }
            }
            function stopBackgroundMusic() {
                try { bgMusic.pause(); } catch (e) { }
            }
            function playSFX(type) {
                try {
                    if (type === "enemyDeath") {
                        enemyDeathSfx.currentTime = 0;
                        enemyDeathSfx.play();
                    } else if (type === "playerDeath") {
                        playerDeathSfx.currentTime = 0;
                        playerDeathSfx.play();
                    }
                } catch (e) { }
            }

            // toca som de boss derrotado apenas 1 vez
            function playBossDefeatedOnce() {
                try {
                    if (!game.bossDefeatedPlayed) {
                        game.bossDefeatedPlayed = true;
                        // garante que a m√∫sica de fundo pare
                        try { bgMusic.pause(); bgMusic.currentTime = 0; } catch (e) { }
                        try { bossDefeatedSfx.currentTime = 0; bossDefeatedSfx.play(); } catch (e) { }
                        // mostra mensagem de vit√≥ria por alguns segundos
                        victoryMsg.style.display = 'flex';
                        setTimeout(() => { victoryMsg.style.display = 'none'; }, 2000);
                    }
                } catch (e) { }
            }

            /* =========================
               Player (inicializa√ß√£o e barras)
               ========================= */
            let player;
            function resetGame() {
                bullets = []; enemies = []; enemyBullets = []; powerups = []; particles = []; boss = null;
                game.running = false; game.paused = false; game.score = 0; game.level = 1; game.waveTimer = 0; game.nextBossScore = 10000;
                game.bossDefeatedPlayed = false;

                // inicializa player dentro da √°rea de jogo (respeitando HUD)
                const startY = clamp(canvas.height / 2, 6, canvas.height - getHudHeight() - 6);
                player = { x: canvas.width * 0.12, y: startY, w: 40, h: 24, speed: 6, cooldown: 0, lives: 3, power: 1, maxLives: 5, invuln: 0 };
                uiScore.textContent = game.score;
                uiLives.textContent = player.lives;
                uiPower.textContent = player.power;
                uiLevel.textContent = game.level;
                updateBars();
            }

            function updateBars() {
                lifeBar.style.width = (player.lives / player.maxLives * 100) + '%';
                lifeBar.style.background = player.lives <= 1 ? 'var(--danger)' : player.lives <= 2 ? 'var(--gold)' : 'var(--accent)';
                powerBar.style.width = (player.power / 6 * 100) + '%';
            }

            /* =========================
               Utilit√°rios
               ========================= */
            function rand(a, b) { return Math.random() * (b - a) + a }
            function clamp(v, a, b) { return Math.max(a, Math.min(b, v)) }
            function rectColl(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y }

            /* =========================
               Spawn de inimigos / powerups / bosses
               - Agora sempre evita a √°rea reservada pelo HUD
               ========================= */
            function spawnEnemy(y, type = 'normal') {
                const d = game.diff;
                // garante que os inimigos nas√ßam acima da zona do HUD
                const playBottom = canvas.height - getHudHeight();
                const minY = 60;
                const maxY = Math.max(minY + 6, playBottom - 60);
                if (typeof y === 'undefined') y = rand(minY, maxY);

                const w = type === 'fast' ? 30 : 36;
                const h = type === 'fast' ? 18 : 24;
                const baseSpeed = (type === 'fast' ? rand(3.6, 5.0) : rand(1.8, 3.2));
                const speed = baseSpeed * d.enemySpeed;
                const baseHp = type === 'fast' ? 3 + Math.floor(game.level / 2) : 6 + Math.floor(game.level * 1.1);
                const hp = Math.max(1, Math.round(baseHp * d.enemyHp));
                enemies.push({ x: canvas.width + rand(30, 200), y, w, h, speed, hp, t: 0, type, fireCd: rand(60, 120) });
            }

            function spawnWave() {
                const d = game.diff;
                const baseCount = 6 + game.level * 2;
                const desiredCount = Math.min(Math.max(1, Math.round(baseCount * d.enemyCount)), 24);

                // limite m√°ximo baseado na dificuldade para evitar muitos inimigos na tela ao mesmo tempo
                const maxOnScreen = Math.max(4, Math.round(12 * d.enemyCount)); // ao menos 4, escal√°vel pela dificuldade

                // spawn apenas at√© atingir o limite
                let canSpawn = Math.max(0, maxOnScreen - enemies.length);
                const count = Math.min(desiredCount, canSpawn);

                for (let i = 0; i < count; i++) {
                    // chama spawnEnemy sem passar y -> spawnEnemy calcula √°rea v√°lida
                    spawnEnemy(undefined, Math.random() < 0.28 ? 'fast' : 'normal');
                }
            }

            function spawnPowerup(x, y) {
                const d = game.diff;
                if (Math.random() < 0.6 * d.powerRate) {
                    const type = Math.random() < 0.5 ? 'power' : 'life';
                    // evita spawn dentro da √°rea do HUD
                    const playBottom = canvas.height - getHudHeight();
                    const py = clamp(y, 18, playBottom - 18);
                    powerups.push({ x, y: py, w: 18, h: 18, type, vx: -2.2 });
                }
            }

            function spawnBoss() {
                const d = game.diff;
                const baseHp = 420 + game.level * 160;
                const w = 200, h = 120;
                // posiciona o boss centralizado, mas garante que n√£o ultrapasse o HUD embaixo
                const playBottom = canvas.height - getHudHeight();
                const initialY = clamp(canvas.height / 2 - h / 2, 20, playBottom - h - 12);
                boss = { x: canvas.width + 260, y: initialY, w, h, hp: Math.max(10, Math.round(baseHp * d.bossHp)), t: 0, cooldown: 0 };
                enemies.push(boss);
            }

            /* =========================
               Tiros e l√≥gica de ataque
               ========================= */
            function playerFire() {
                if (player.cooldown > 0) return;
                const shots = player.power >= 5 ? 4 : player.power >= 3 ? 3 : 1;
                const spread = player.power >= 4 ? 0.2 : (player.power >= 2 ? 0.1 : 0);
                const baseDmg = 2 + Math.floor(player.power * 1.5);
                for (let i = 0; i < shots; i++) {
                    const a = (i - (shots - 1) / 2) * spread;
                    bullets.push({ x: player.x + player.w, y: player.y + (i - (shots - 1) / 2) * 6, w: 10 + player.power * 1.6, h: 4 + player.power * 0.6, vx: 12, vy: a * 12, dmg: baseDmg });
                }
                player.cooldown = clamp(8 - Math.floor(player.power * 0.9), 3, 12);
            }

            function enemyShoot(e) {
                if (!e) return;
                const d = game.diff;
                if (e === boss) {
                    // chefe atira na dire√ß√£o do jogador em linha reta (sem espalhamento)
                    const baseShots = 7;
                    const n = Math.max(1, Math.floor(baseShots * d.bossBullets));
                    for (let i = 0; i < n; i++) {
                        const angle = Math.atan2(player.y - (e.y + e.h / 2), player.x - (e.x - 10));
                        enemyBullets.push({ x: e.x - 6, y: e.y + e.h / 2, w: 10, h: 10, vx: Math.cos(angle) * 6.2, vy: Math.sin(angle) * 6.2, dmg: 2 + Math.floor(game.level / 6) });
                    }
                } else {
                    // inimigos menores disparam em linha reta horizontal (sem vy rand√¥mico)
                    const speed = -4 - (d.enemySpeed - 1) * 1.2; // leva em conta a dificuldade levemente
                    enemyBullets.push({ x: e.x, y: e.y + e.h / 2, w: 6, h: 6, vx: speed, vy: 0, dmg: 1 });
                }
            }

            /* =========================
               Explosion visual
               ========================= */
            function makeExplosion(x, y, color, count = 18) {
                for (let i = 0; i < count; i++) {
                    particles.push({ x, y, vx: rand(-4, 4), vy: rand(-5, 3), life: rand(30, 110), col: color });
                }
            }

            /* =========================
               Player hit (perda de vida / game over)
               ========================= */
            function hitPlayer(dmg) {
                if (player.invuln && player.invuln > 0) return;
                player.lives -= dmg;
                player.lives = Math.max(0, player.lives);
                uiLives.textContent = player.lives;
                updateBars();
                makeExplosion(player.x + player.w / 2, player.y + player.h / 2, '#ffdd88', 20);
                if (player.lives <= 0) {
                    // som de morte do jogador
                    playSFX('playerDeath');

                    game.running = false;
                    menu.querySelector('h1').innerText = '‚ò† Game Over';
                    menu.style.display = 'flex';
                    // parar m√∫sica de fundo
                    stopBackgroundMusic();
                } else {
                    // breve invencibilidade ap√≥s o hit
                    player.invuln = 60; // frames-ish (we'll decrement by dt in update)
                    // N√ÉO mover o jogador de volta para posi√ß√£o inicial ‚Äî mant√©m onde recebeu dano
                    player.cooldown = 14;
                }
            }

            /* =========================
               Loop principal (update + render)
               ========================= */
            let last = performance.now();
            function loop(now) {
                const dt = clamp((now - last) / 16.6667, 0, 3);
                last = now;

                if (game.running && !game.paused) {
                    update(dt);
                }
                render();
                requestAnimationFrame(loop);
            }

            /* =========================
               Update (l√≥gica do jogo)
               - Aqui adicionamos clamps para garantir que player & inimigos
                 nunca entrem na √°rea do HUD.
               ========================= */
            function update(dt) {
                // estrelas
                for (let s of stars) {
                    s.x -= s.s * dt * 1.6;
                    if (s.x < -4) { s.x = canvas.width + 4; s.y = Math.random() * canvas.height; }
                }

                // input movement
                if (keys['w'] || keys['arrowup']) player.y -= player.speed * dt;
                if (keys['s'] || keys['arrowdown']) player.y += player.speed * dt;
                if (keys['a'] || keys['arrowleft']) player.x -= player.speed * dt;
                if (keys['d'] || keys['arrowright']) player.x += player.speed * dt;

                // limitar player para n√£o entrar no HUD (usa getHudHeight())
                player.x = clamp(player.x, 6, canvas.width * 0.58);
                player.y = clamp(player.y, 6, canvas.height - getHudHeight() - player.h - 6);

                if (keys.space) playerFire();
                if (player.cooldown > 0) player.cooldown -= dt;
                if (player.invuln && player.invuln > 0) player.invuln -= dt;

                // update bullets
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    b.x += (b.vx || 12) * dt;
                    b.y += (b.vy || 0) * dt;
                    if (b.x > canvas.width + 60 || b.y < -60 || b.y > canvas.height + 60) bullets.splice(i, 1);
                }

                // update enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const e = enemies[i];
                    e.t = (e.t || 0) + dt;
                    if (e === boss) {
                        // boss movement: ease to position then hover (mas n√£o invade o HUD)
                        e.x += (canvas.width - 360 - e.x) * 0.02 * dt * 60;
                        const hover = canvas.height / 2 - e.h / 2 + Math.sin(e.t * 0.02) * 34;
                        e.y = clamp(hover, 12, canvas.height - getHudHeight() - e.h - 12);
                        e.cooldown = (e.cooldown || 0) + dt;
                        if (e.cooldown > Math.max(40 - game.level * 2, 22)) { enemyShoot(e); e.cooldown = 0; }
                    } else {
                        if (e.type === 'fast') e.y += Math.sin(e.t * 0.36) * 2.8 * dt;
                        e.x -= e.speed * dt * (e.type === 'fast' ? 1.6 : 1);

                        // impede que inimigos ultrapassem a √°rea do HUD
                        e.y = clamp(e.y, 6, canvas.height - getHudHeight() - e.h - 6);

                        // tiro mais regular
                        e.fireCd -= dt;
                        if (e.fireCd <= 0) {
                            enemyShoot(e);
                            e.fireCd = rand(60, 120);
                        }
                    }
                    if (e.x < -260) enemies.splice(i, 1);
                }

                // enemy bullets
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    const b = enemyBullets[i];
                    b.x += (b.vx || -4) * dt;
                    b.y += (b.vy || 0) * dt;
                    if (rectColl({ x: b.x, y: b.y, w: b.w, h: b.h }, { x: player.x, y: player.y, w: player.w, h: player.h })) {
                        enemyBullets.splice(i, 1);
                        hitPlayer(b.dmg || 1);
                        continue;
                    }
                    if (b.x < -120 || b.x > canvas.width + 120 || b.y < -120 || b.y > canvas.height + 120) enemyBullets.splice(i, 1);
                }

                // bullets vs enemies collisions (player bullets hitting enemies)
                for (let ei = enemies.length - 1; ei >= 0; ei--) {
                    const e = enemies[ei];
                    let hit = false;
                    for (let bi = bullets.length - 1; bi >= 0; bi--) {
                        const b = bullets[bi];
                        if (rectColl({ x: b.x, y: b.y, w: b.w, h: b.h }, { x: e.x, y: e.y, w: e.w, h: e.h })) {
                            e.hp -= b.dmg || 1;
                            bullets.splice(bi, 1);
                            makeExplosion(b.x, b.y, '#fff', 8);
                            hit = true;
                            if (e.hp <= 0) {
                                // morte do inimigo
                                makeExplosion(e.x + e.w / 2, e.y + e.h / 2, e === boss ? '#ff9fb1' : '#8bd3ff', 24);
                                game.score += (e === boss ? 900 : 140);
                                uiScore.textContent = game.score;
                                if (Math.random() < 0.32) spawnPowerup(e.x, e.y);
                                if (e === boss) {
                                    boss = null;
                                    enemies.splice(ei, 1);
                                    game.level++;
                                    uiLevel.textContent = game.level;
                                    game.running = false;
                                    menu.querySelector('h1').innerText = 'üî• Chefe derrotado!';
                                    menu.style.display = 'flex';
                                    // parar m√∫sica e tocar som de vit√≥ria apenas 1 vez
                                    playBossDefeatedOnce();
                                } else {
                                    playSFX('enemyDeath');
                                    enemies.splice(ei, 1);
                                }

                                // Ao atualizar o score, verificar se atingiu o limiar para boss
                                if (!boss && game.score >= game.nextBossScore) {
                                    // apenas mostra o aviso aqui; spawn real ficar√° 3s depois
                                    showBossWarning();
                                    setTimeout(() => {
                                        // garanta que n√£o exista boss j√° criado (double-check)
                                        if (!boss) {
                                            spawnBoss();
                                        }
                                    }, 3000);
                                    game.nextBossScore += 10000;
                                }

                                break;
                            }
                        }
                    }
                    if (hit) continue;
                }

                // colis√£o direta INIMIGO ‚Üî JOGADOR (novo: causa dano se tocar)
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const e = enemies[i];
                    if (rectColl({ x: player.x, y: player.y, w: player.w, h: player.h }, { x: e.x, y: e.y, w: e.w, h: e.h })) {
                        // causar dano e explodir o inimigo (ou causar dano ao boss de forma reduzida)
                        if (e === boss) {
                            // dano reduzido ao boss se colidir (player sofre 1)
                            hitPlayer(1);
                            // opcional: causar pequeno dano ao boss
                            e.hp -= 6;
                            makeExplosion(player.x + player.w / 2, player.y + player.h / 2, '#ff9fb1', 12);
                            if (e.hp <= 0) {
                                // matar boss
                                makeExplosion(e.x + e.w / 2, e.y + e.h / 2, '#ff9fb1', 32);
                                game.score += 900;
                                uiScore.textContent = game.score;
                                boss = null;
                                enemies.splice(i, 1);
                                game.level++;
                                uiLevel.textContent = game.level;
                                game.running = false;
                                menu.querySelector('h1').innerText = 'üî• Chefe derrotado!';
                                menu.style.display = 'flex';
                                // tocar som de vit√≥ria apenas 1 vez
                                playBossDefeatedOnce();
                            }
                        } else {
                            // inimigo comum: remove inimigo e d√° dano ao jogador
                            enemies.splice(i, 1);
                            hitPlayer(1);
                            makeExplosion(e.x + e.w / 2, e.y + e.h / 2, '#8bd3ff', 12);
                        }
                    }
                }

                // powerups
                for (let i = powerups.length - 1; i >= 0; i--) {
                    const p = powerups[i];
                    p.x += (p.vx || -2) * dt;
                    if (rectColl({ x: p.x, y: p.y, w: p.w, h: p.h }, { x: player.x, y: player.y, w: player.w, h: player.h })) {
                        if (p.type === 'life' && player.lives < player.maxLives) { player.lives++; uiLives.textContent = player.lives; }
                        else if (p.type === 'power') { player.power = Math.min(6, player.power + 1); uiPower.textContent = player.power; }
                        updateBars();
                        powerups.splice(i, 1);
                        continue;
                    }
                    if (p.x < -80) powerups.splice(i, 1);
                }

                // particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.vy += 0.18 * dt;
                    p.life -= 1 * dt;
                    if (p.life <= 0) particles.splice(i, 1);
                }

                // l√≥gica de spawn
                game.waveTimer -= dt;
                if (game.waveTimer <= 0 && !boss) {
                    spawnWave();
                    game.waveTimer = 100;
                }

                // chefe aparece em m√∫ltiplos do limiar definido (controle via nextBossScore)
                if (!boss && game.score >= game.nextBossScore) {
                    showBossWarning();
                    setTimeout(() => {
                        if (!boss) spawnBoss();
                    }, 3000);
                    game.nextBossScore += 10000;
                }
            }

            /* =========================
               Render (tudo em canvas)
               ========================= */
            function render() {
                ctx.fillStyle = '#02081A';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // estrelas
                for (const s of stars) {
                    ctx.fillStyle = 'rgba(255,255,255,' + clamp(0.04 + (s.s / 1.4) * 0.58, 0.02, 0.9) + ')';
                    ctx.fillRect(s.x, s.y, Math.max(1, s.s), Math.max(1, s.s));
                }

                // player
                ctx.save();
                ctx.translate(player.x, player.y);
                // nave (triangular)
                ctx.beginPath();
                ctx.moveTo(18, 0);
                ctx.lineTo(-12, 12);
                ctx.lineTo(-12, -12);
                ctx.closePath();
                ctx.fillStyle = '#8ff7d3';
                ctx.fill();

                // cockpit
                ctx.beginPath();
                ctx.ellipse(6, 0, 6, 5, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#053657';
                ctx.fill();

                // thruster / flame
                const t = performance.now() * 0.01;
                ctx.beginPath();
                ctx.moveTo(-12, 6);
                ctx.lineTo(-20 - Math.sin(t) * 3, 0);
                ctx.lineTo(-12, -6);
                ctx.fillStyle = 'rgba(255,165,0,0.95)';
                ctx.fill();

                // se estiver invulner√°vel, pisca
                if (player.invuln && player.invuln > 0) {
                    ctx.globalAlpha = (Math.sin(performance.now() * 0.02) > 0) ? 0.4 : 1;
                }
                ctx.restore();
                ctx.globalAlpha = 1;

                // balas do player
                for (const b of bullets) {
                    ctx.fillStyle = 'hsl(' + (40 + player.power * 18) + ',90%,' + (55 + player.power * 3) + '%)';
                    ctx.fillRect(b.x, b.y, b.w, b.h);
                    ctx.globalAlpha = 0.25;
                    ctx.fillRect(b.x - 4, b.y, 3, b.h);
                    ctx.globalAlpha = 1;
                }

                // inimigos e boss
                for (const e of enemies) {
                    if (e === boss) {
                        ctx.save();
                        ctx.translate(e.x, e.y);

                        // corpo principal
                        ctx.fillStyle = '#ff4f6d';
                        // roundRect fallback
                        if (ctx.roundRect) {
                            ctx.beginPath();
                            ctx.roundRect(0, 0, e.w, e.h, 20);
                            ctx.fill();
                        } else {
                            // desenhar ret√¢ngulo com cantos arredondados manualmente
                            const r = 20;
                            ctx.beginPath();
                            ctx.moveTo(r, 0);
                            ctx.lineTo(e.w - r, 0);
                            ctx.quadraticCurveTo(e.w, 0, e.w, r);
                            ctx.lineTo(e.w, e.h - r);
                            ctx.quadraticCurveTo(e.w, e.h, e.w - r, e.h);
                            ctx.lineTo(r, e.h);
                            ctx.quadraticCurveTo(0, e.h, 0, e.h - r);
                            ctx.lineTo(0, r);
                            ctx.quadraticCurveTo(0, 0, r, 0);
                            ctx.closePath();
                            ctx.fill();
                        }

                        // asas laterais
                        ctx.fillStyle = '#d92f4d';
                        ctx.fillRect(-30, 20, 30, e.h - 40);
                        ctx.fillRect(e.w, 20, 30, e.h - 40);

                        // olho central animado
                        ctx.beginPath();
                        ctx.arc(e.w / 2, e.h / 2, 28, 0, Math.PI * 2);
                        ctx.fillStyle = '#fff';
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(e.w / 2, e.h / 2, 20, 0, Math.PI * 2);
                        ctx.fillStyle = '#000';
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(e.w / 2 + Math.sin(performance.now() * 0.01) * 6, e.h / 2, 10, 0, Math.PI * 2);
                        ctx.fillStyle = '#0ff';
                        ctx.fill();

                        // motores do boss
                        for (let i = 0; i < 3; i++) {
                            let fx = (e.w / 4) * (i + 1);
                            ctx.fillStyle = 'orange';
                            ctx.beginPath();
                            ctx.moveTo(fx - 6, e.h);
                            ctx.lineTo(fx + 6, e.h);
                            ctx.lineTo(fx, e.h + 12 + Math.sin(performance.now() * 0.02 + i) * 6);
                            ctx.closePath();
                            ctx.fill();
                        }
                        ctx.restore();

                        // barra de vida do boss (topo)
                        const baseMaxHp = 420 + game.level * 160;
                        const maxHp = baseMaxHp * game.diff.bossHp;
                        const bw = clamp((e.hp / maxHp), 0, 1) * 240;
                        ctx.fillStyle = 'rgba(255,255,255,0.06)';
                        ctx.fillRect(canvas.width / 2 - 120, 18, 240, 14);
                        ctx.fillStyle = '#ff6b6b';
                        ctx.fillRect(canvas.width / 2 - 120, 18, bw, 14);
                        ctx.fillStyle = 'rgba(255,255,255,0.9)';
                        ctx.font = '12px Inter, Arial';
                        ctx.fillText('CHEFE', canvas.width / 2 - 18, 17);

                    } else {
                        ctx.save();
                        ctx.translate(e.x, e.y);

                        if (e.type === 'fast') {
                            // inimigos r√°pidos ‚Üí ca√ßa triangular
                            ctx.fillStyle = '#ffd86b';
                            ctx.beginPath();
                            ctx.moveTo(0, e.h / 2);
                            ctx.lineTo(e.w, 0);
                            ctx.lineTo(e.w, e.h);
                            ctx.closePath();
                            ctx.fill();

                            // cabine
                            ctx.fillStyle = '#333';
                            ctx.beginPath();
                            ctx.arc(e.w * 0.6, e.h / 2, 5, 0, Math.PI * 2);
                            ctx.fill();

                            // motor
                            ctx.fillStyle = 'rgba(255,100,0,0.8)';
                            ctx.beginPath();
                            ctx.moveTo(0, e.h / 2 - 4);
                            ctx.lineTo(-8, e.h / 2);
                            ctx.lineTo(0, e.h / 2 + 4);
                            ctx.closePath();
                            ctx.fill();

                        } else {
                            // inimigos normais ‚Üí nave circular com pulsar
                            let pulse = 0.2 * Math.sin(performance.now() * 0.01) + 1;
                            ctx.fillStyle = '#58b8ff';
                            ctx.beginPath();
                            ctx.arc(e.w / 2, e.h / 2, (e.w / 2) * pulse, 0, Math.PI * 2);
                            ctx.fill();

                            // detalhe interno
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(e.w / 2, e.h / 2, e.w / 3, 0, Math.PI * 2);
                            ctx.stroke();

                            // cockpit
                            ctx.fillStyle = '#042';
                            ctx.beginPath();
                            ctx.arc(e.w / 2, e.h / 2, 5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.restore();
                    }
                }

                // tiros inimigos
                for (const b of enemyBullets) {
                    ctx.fillStyle = '#ffb07a';
                    ctx.fillRect(b.x, b.y, b.w || 6, b.h || 6);
                }

                // powerups
                for (const p of powerups) {
                    ctx.beginPath();
                    ctx.fillStyle = p.type === 'life' ? 'var(--danger)' : 'var(--accent)';
                    ctx.arc(p.x, p.y, 9, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#042';
                    ctx.font = '12px monospace';
                    ctx.fillText(p.type === 'life' ? '‚ô•' : '+', p.x - 5, p.y + 5);
                }

                // part√≠culas
                for (const p of particles) {
                    ctx.globalAlpha = clamp(p.life / 110, 0, 1);
                    ctx.fillStyle = p.col;
                    ctx.fillRect(p.x, p.y, 3, 3);
                    ctx.globalAlpha = 1;
                }

                // OBS: o HUD √© DOM e est√° em cima do canvas; n√£o √© necess√°rio desenhar a faixa no canvas.
            }

            /* =========================
               Start / Pause / Controls
               ========================= */
            function startGame(choice) {
                game.diffKey = choice || game.diffKey || 'medium';
                game.diff = DIFFICULTIES[game.diffKey] || DIFFICULTIES.medium;
                resetGame();
                game.running = true;
                menu.style.display = 'none';

                // reset flag de som do boss (para poder tocar quando novo boss for derrotado)
                game.bossDefeatedPlayed = false;

                // m√∫sica s√≥ toca aqui
                startBackgroundMusic();

                last = performance.now();
            }

            function togglePause() {
                if (!game.running) return;
                game.paused = !game.paused;
                if (game.paused) {
                    // mostra menu de pausa (n√£o sobreescreve o menu principal)
                    pauseMenu.querySelector('h1').innerText = '|| Pausado';
                    pauseMenu.style.display = 'flex';
                    stopBackgroundMusic(); // pausa a m√∫sica
                } else {
                    pauseMenu.style.display = 'none';
                    // retoma m√∫sica ao despausar (se o boss ainda n√£o foi derrotado)
                    if (!game.bossDefeatedPlayed) startBackgroundMusic();
                    last = performance.now();
                }
            }

            // difficulty buttons
            diffButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    diffButtons.forEach(b => b.style.outline = 'none');
                    btn.style.outline = '2px solid rgba(255,255,255,0.08)';
                    menu.setAttribute('data-selected-diff', btn.dataset.diff);
                    game.diffKey = btn.dataset.diff;
                    game.diff = DIFFICULTIES[game.diffKey] || DIFFICULTIES.medium;
                });
            });

            // start button
            startBtn.addEventListener('click', () => {
                const sel = menu.getAttribute('data-selected-diff') || 'medium';
                startGame(sel);
            });

            // pause menu buttons
            continueBtn.addEventListener('click', () => {
                togglePause();
            });
            restartBtn.addEventListener('click', () => {
                const sel = menu.getAttribute('data-selected-diff') || game.diffKey || 'medium';
                startGame(sel);
                pauseMenu.style.display = 'none';
            });
            mainMenuBtn.addEventListener('click', () => {
                game.running = false;
                game.paused = false;
                pauseMenu.style.display = 'none';
                menu.style.display = 'flex';
                stopBackgroundMusic();
            });

            // enter para iniciar (redundante, mas seguro)
            addEventListener('keydown', e => {
                if (e.key === 'Enter' && !game.running) {
                    const sel = menu.getAttribute('data-selected-diff') || 'medium';
                    startGame(sel);
                }
            });

            // iniciar
            resetGame();
            menu.style.display = 'flex';
            requestAnimationFrame(loop);

            // garantir que o AudioContext/outros sons sejam reativados em gesto do usu√°rio
            ['click', 'keydown', 'touchstart'].forEach(ev => {
                addEventListener(ev, () => {
                    try { if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); } catch (e) { }
                    try { if (bgMusic && bgMusic.paused && !game.bossDefeatedPlayed) bgMusic.play(); } catch (e) { }
                }, { once: false });
            });

            /* =========================
               UI extras: esconder a dica do HUD ap√≥s alguns segundos
               ========================= */
            setTimeout(() => {
                const hs = document.getElementById("hudSmall");
                if (hs) {
                    hs.style.transition = "opacity .36s";
                    hs.style.opacity = "0";
                    setTimeout(() => { hs.style.display = "none"; }, 400);
                }
            }, 8000); // esconde ap√≥s 8s

            // fim do IIFE
        })();
    </script>
</body>

</html>
