<!DOCTYPE html> <!-- Declara que este documento √© HTML5 -->
<html lang="pt-BR"> <!-- Define o idioma da p√°gina como Portugu√™s do Brasil -->
<head>
  <meta charset="UTF-8"> <!-- Define a codifica√ß√£o de caracteres como UTF-8 -->
  <title>Snake Game</title> <!-- T√≠tulo que aparece na aba do navegador -->

  <style>
    /* ===================== ESTILO DO BODY ===================== */
    body {
      margin: 0; /* Remove margens padr√£o do body do navegador */
      display: flex; /* Usa flexbox para posicionar conte√∫do */
      justify-content: center; /* Centraliza horizontalmente o conte√∫do do body */
      align-items: center; /* Centraliza verticalmente o conte√∫do do body */
      height: 100vh; /* Faz o body ter 100% da altura da viewport */
      background: linear-gradient(135deg, #2c3e50, #3498db); /* Fundo em degrad√™ diagonal */
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Pilha de fontes padr√£o */
    }

    /* ===================== ESTILO DO CANVAS ===================== */
    canvas {
      background: #ecf0f1; /* Cor de fundo do canvas (onde desenhamos o jogo) */
      border: 8px solid #2c3e50; /* Borda s√≥lida ao redor do canvas */
      border-radius: 12px; /* Bordas arredondadas no canvas */
      box-shadow: 0 8px 20px rgba(0,0,0,0.4); /* Sombra para dar profundidade */
    }

    /* ===================== OVERLAY (MENUS) ===================== */
    #overlay {
      position: absolute; /* Posicionamento absoluto para cobrir a tela */
      top: 0; left: 0; /* Come√ßa no canto superior esquerdo */
      width: 100%; height: 100%; /* Ocupa toda a √°rea vis√≠vel */
      display: flex; /* Usa flexbox para alinhar conte√∫do do overlay */
      justify-content: center; /* Centraliza conte√∫do horizontalmente */
      align-items: center; /* Centraliza conte√∫do verticalmente */
      flex-direction: column; /* Organiza filhos em coluna (vertical) */
      background: rgba(44,62,80,0.85); /* Fundo escuro semi-transparente */
      color: #fff; /* Cor do texto dentro do overlay */
      font-size: 24px; /* Tamanho da fonte no overlay */
    }

    /* ===================== BOT√ïES, SELECT, LABEL E INPUT (ESTILO COMUM) ===================== */
    button, select, label, input {
      margin: 10px; /* Espa√ßamento externo entre controles */
      padding: 12px 28px; /* Preenchimento interno dos controles */
      font-size: 18px; /* Tamanho da fonte dos controles */
      font-weight: bold; /* Texto em negrito nos controles */
      border: none; /* Remove bordas padr√£o */
      border-radius: 8px; /* Cantos arredondados */
      cursor: pointer; /* Cursor de ponteiro ao passar em elementos clic√°veis */
    }

    /* ===================== BOT√ÉO ===================== */
    button {
      background: #27ae60; /* Cor de fundo verde para bot√µes */
      color: #fff; /* Texto branco nos bot√µes */
      transition: background 0.3s; /* Transi√ß√£o suave ao mudar a cor (hover) */
    }
    button:hover { background: #2ecc71; } /* Cor do bot√£o ao passar o mouse */

    /* ===================== SELECT ===================== */
    select {
      background: #fff; /* Fundo branco para selects */
      color: #2c3e50; /* Texto escuro nos selects */
    }

    /* ===================== LABEL ===================== */
    label {
      font-weight: normal; /* Label com peso de fonte normal */
      padding: 0; /* Remove padding */
      margin: 6px; /* Pequeno espa√ßamento externo */
    }

    /* ===================== CHECKBOX ===================== */
    input[type="checkbox"]{
      width:18px; /* Largura do checkbox */
      height:18px; /* Altura do checkbox */
    }
  </style>
</head>
<body>
  <!-- Canvas onde o jogo ser√° desenhado -->
  <canvas id="gameCanvas" width="600" height="600"></canvas>

  <!-- Div usada como overlay para menus e mensagens (Game Over, op√ß√µes, etc.) -->
  <div id="overlay"></div>

  <script>
  // ==================== VARI√ÅVEIS GLOBAIS ====================
  // Refer√™ncia ao elemento canvas onde desenharemos o jogo
  const canvas = document.getElementById('gameCanvas'); // pega o elemento canvas pelo id
  // Contexto 2D do canvas (API utilizada para desenhar formas, texto, imagens)
  const ctx = canvas.getContext('2d'); // obt√©m o contexto 2D
  // Refer√™ncia ao elemento overlay (menu e telas)
  const overlay = document.getElementById('overlay'); // pega a div do overlay

  // Estado principal do jogo (ser√£o inicializados em startSnake)
  let snake, dir, food, score, lives; // cobra (array), dire√ß√£o, comida, pontua√ß√£o, vidas

  // Configura√ß√µes b√°sicas
  let cell = 20; // tamanho de cada c√©lula (em pixels)
  let gameSpeed = 100; // velocidade do jogo em ms (quanto menor = mais r√°pido)
  let mapSize = 600; // tamanho padr√£o do mapa (canvas), em pixels
  let frameCount = 0; // contador de frames para anima√ß√µes (ex: l√≠ngua piscante)

  // ==================== SONS ====================
  // M√∫sica de fundo (arquivo local 'Musica.mp3' ‚Äî substitua pelo seu caminho se necess√°rio)
  const music = new Audio('Musica.mp3'); // cria objeto Audio para m√∫sica
  music.loop = true; // configura para tocar em loop cont√≠nuo
  music.preload = 'auto'; // solicita pr√©-carregamento do √°udio
  music.volume = 0.5; // volume inicial da m√∫sica (0.0 a 1.0)

  // Som ao comer (arquivo local 'Maca.mp3')
  const eatSound = new Audio('Maca.mp3'); // cria objeto Audio para o efeito de comer
  eatSound.preload = 'auto'; // pr√©-carrega o som
  eatSound.volume = 0.9; // volume do efeito de comer

  // Som de morte (arquivo local 'Morte.mp3')
  const deathSound = new Audio('Morte.mp3'); // cria objeto Audio para som de morte
  deathSound.preload = 'auto'; // pr√©-carrega o som
  deathSound.volume = 0.9; // volume do som de morte

  // Flag para controlar se som est√° ativo
  let soundEnabled = true; // true = efeitos e m√∫sica tocam; false = sil√™ncio

  // ==================== TENTA TOCAR M√öSICA AUTOMATICAMENTE ====================
  // Alguns navegadores bloqueiam autoplay ‚Äî essa fun√ß√£o tenta tocar e, se falhar, mostra bot√£o para ativar som
  function tryPlayMusic(){
    if(!soundEnabled) return; // se o usu√°rio desativou som nas op√ß√µes, n√£o tenta tocar
    // tenta tocar a m√∫sica (retorna uma Promise)
    music.play().then(()=>{ 
      // se iniciou com sucesso, logamos no console
      console.log('M√∫sica tocando');
    }).catch(err=>{
      // se houve erro (autoplay bloqueado), mostramos aviso no console e um bot√£o para ativar manualmente
      console.warn('Reprodu√ß√£o autom√°tica bloqueada pelo navegador:', err);
      showEnableSoundButton(); // cria um bot√£o vis√≠vel para o usu√°rio ativar o som
    });
  }

  // ==================== BOT√ÉO PARA ATIVAR SOM (CASO AUTOPLAY SEJA BLOQUEADO) ====================
  // Cria um bot√£o flutuante para o usu√°rio ativar √°udio manualmente
  function showEnableSoundButton(){
    const btnId = 'enable-sound-btn'; // id do bot√£o para evitar duplicatas
    if(document.getElementById(btnId)) return; // se j√° existe, n√£o cria outro
    const btn = document.createElement('button'); // cria elemento button
    btn.id = btnId; // define id
    btn.textContent = 'Ativar Som'; // texto do bot√£o
    // estilos inline m√≠nimos para posicionar o bot√£o no canto superior direito
    btn.style.position = 'absolute';
    btn.style.right = '16px';
    btn.style.top = '16px';
    btn.style.padding = '8px 12px';
    btn.style.fontSize = '14px';
    document.body.appendChild(btn); // adiciona bot√£o ao body
    // ao clicar, tenta tocar a m√∫sica novamente e remove o bot√£o se tiver sucesso
    btn.addEventListener('click', ()=>{
      music.play().then(()=>{ btn.remove(); }).catch(e=>{
        // se ainda falhar, apenas loga o erro (pode acontecer se o usu√°rio bloquear √°udio)
        console.error('Erro ao tentar tocar m√∫sica ap√≥s clique:', e);
      });
    });
  }

  // ==================== FUN√á√ÉO PARA TOCAR EFEITOS (REUS√ÅVEL) ====================
  // Recebe um objeto Audio e tenta toc√°-lo respeitando a flag soundEnabled
  function playSound(sound){
    if(!soundEnabled) return; // se som desativado nas op√ß√µes, n√£o toca nada
    try{ sound.currentTime = 0; }catch(e){} // tenta resetar para o in√≠cio (compatibilidade)
    // toca o som; se der erro (ex: bloqueio), apenas logamos no console
    sound.play().catch(err=>{
      console.warn('Erro ao reproduzir som:', err);
    });
  }

  // ==================== FUN√á√ïES DE OVERLAY / MENUS ====================
  // Mostra o overlay com conte√∫do HTML (recebe string com HTML)
  function showOverlay(html){ overlay.innerHTML = html; overlay.style.display = 'flex'; }
  // Esconde o overlay (coloca display none)
  function hideOverlay(){ overlay.style.display = 'none'; }

  // ==================== MENU PRINCIPAL ====================
  function mainMenu(){
    try{ music.pause(); music.currentTime = 0; }catch(e){} // para a m√∫sica quando volta ao menu (seguran√ßa)
    showOverlay(`
      <h1>üêç Snake Game</h1>
      <button onclick="startSnake()">START</button>
      <button onclick="optionsMenu()">Op√ß√µes</button>
    `); // injeta HTML com bot√µes que chamam startSnake e optionsMenu
  }

  // ==================== MENU DE OP√á√ïES ====================
  function optionsMenu(){
    showOverlay(`
      <h2>‚öôÔ∏è Op√ß√µes</h2>
      <div style="display:flex;flex-direction:column;align-items:center;">
        <label for="difficulty">Dificuldade (velocidade)</label>
        <select id="difficulty">
          <option value="120">F√°cil</option>
          <option value="100" selected>M√©dio</option>
          <option value="60">Dif√≠cil</option>
        </select>
        <label for="mapSize">Tamanho do mapa</label>
        <select id="mapSize">
          <option value="400">Pequeno</option>
          <option value="600" selected>M√©dio</option>
          <option value="800">Grande</option>
        </select>
        <div style="margin-top:10px; display:flex; align-items:center; gap:8px;">
          <input type="checkbox" id="soundOn" checked />
          <label for="soundOn">Som ativado</label>
        </div>
        <div style="margin-top:12px;">
          <button onclick="applyOptions()">Salvar</button>
          <button onclick="mainMenu()">Voltar</button>
        </div>
      </div>
    `); // injeta op√ß√µes: dificuldade (velocidade), tamanho do mapa e checkbox de som
  }

  // ==================== APLICAR OP√á√ïES ====================
  function applyOptions(){
    // pega valores selecionados no menu de op√ß√µes
    const diff = document.getElementById('difficulty').value; // valor da dificuldade (string)
    const size = document.getElementById('mapSize').value; // valor do tamanho do mapa (string)
    const soundOnCheckbox = document.getElementById('soundOn'); // checkbox de som

    gameSpeed = parseInt(diff); // converte string para n√∫mero e aplica velocidade do jogo
    mapSize = parseInt(size); // aplica novo tamanho do mapa
    soundEnabled = !!soundOnCheckbox.checked; // aplica prefer√™ncia de som (boolean)

    // ajusta o tamanho do canvas para o novo mapSize escolhido
    canvas.width = mapSize;
    canvas.height = mapSize;

    if(!soundEnabled){ try{ music.pause(); }catch(e){} } // se desativou som, pausa a m√∫sica
    mainMenu(); // volta ao menu principal
  }

  // ==================== INICIA O JOGO (CONFIGURA√á√ÉO INICIAL) ====================
  function startSnake(){
    hideOverlay(); // esconde o overlay para mostrar o jogo

    // calcula a posi√ß√£o inicial centralizada (arredondando para m√∫ltiplos da c√©lula)
    const startX = Math.floor((canvas.width/2)/cell)*cell; // coordenada X alinhada √† grade
    const startY = Math.floor((canvas.height/2)/cell)*cell; // coordenada Y alinhada √† grade
    // cria a cobra inicial com 3 segmentos (cada segmento √© [x,y])
    snake = [ [startX, startY], [startX-cell, startY], [startX-2*cell, startY] ];
    dir = [1,0]; // dire√ß√£o inicial: para a direita (vetor [dx,dy])

    food = randomFood(); // gera a primeira comida em posi√ß√£o aleat√≥ria v√°lida
    score = 0; // zera pontua√ß√£o
    lives = 3; // define n√∫mero inicial de vidas
    frameCount = 0; // zera contador de frames (usado em anima√ß√µes como a l√≠ngua)

    tryPlayMusic(); // tenta tocar a m√∫sica de fundo (pode abrir bot√£o de ativar som)
    snakeLoop(); // inicia o loop principal do jogo
  }

  // ==================== GERAR COMIDA (POSI√á√ÉO ALEAT√ìRIA) ====================
  function randomFood(){
    let fx, fy; // vari√°veis para coordenadas da comida
    do{
      // calcula posi√ß√£o aleat√≥ria alinhada √† grade (multiplo de 'cell')
      fx = Math.floor(Math.random()*(canvas.width/cell))*cell; // posi√ß√£o X aleat√≥ria
      fy = Math.floor(Math.random()*(canvas.height/cell))*cell; // posi√ß√£o Y aleat√≥ria
      // repete enquanto a posi√ß√£o coincidir com algum segmento da cobra (evita spawn em cima da cobra)
    } while(snake.some(seg=>seg[0]===fx && seg[1]===fy));
    return [fx, fy]; // retorna array [x,y] da comida
  }

  // ==================== LOOP PRINCIPAL DO JOGO (DESENHO E L√ìGICA) ====================
  function snakeLoop(){
    ctx.clearRect(0,0,canvas.width,canvas.height); // limpa o canvas inteiro antes de redesenhar
    frameCount++; // incrementa contador de frames (usado para anima√ß√µes)

    // ==================== DESENHAR GRID ====================
    ctx.strokeStyle = '#e1e5e9'; // cor das linhas da grid
    // desenha linhas verticais a cada 'cell' pixels
    for(let x=0;x<canvas.width;x+=cell){ 
      ctx.beginPath(); // inicia novo caminho
      ctx.moveTo(x,0); // move para topo da linha
      ctx.lineTo(x,canvas.height); // desenha at√© o fundo
      ctx.stroke(); // aplica o tra√ßo
    }
    // desenha linhas horizontais a cada 'cell' pixels
    for(let y=0;y<canvas.height;y+=cell){ 
      ctx.beginPath(); // inicia novo caminho
      ctx.moveTo(0,y); // move para o in√≠cio da linha
      ctx.lineTo(canvas.width,y); // desenha at√© o final
      ctx.stroke(); // aplica o tra√ßo
    }

    // ==================== MOVIMENTA√á√ÉO DA COBRA ====================
    // calcula nova posi√ß√£o da cabe√ßa com base na dire√ß√£o atual
    const head = [snake[0][0] + dir[0]*cell, snake[0][1] + dir[1]*cell];
    // verifica colis√£o com paredes (fora do canvas)
    const hitWall = head[0] < 0 || head[1] < 0 || head[0] >= canvas.width || head[1] >= canvas.height;
    // verifica colis√£o com o pr√≥prio corpo (algum segmento com mesma posi√ß√£o)
    const hitSelf = snake.some(seg => seg[0] === head[0] && seg[1] === head[1]);
    if(hitWall || hitSelf){
      // ao colidir, perde-se uma vida
      lives -= 1;
      if(lives <= 0){ // se n√£o sobrou vida, toca som de morte e finaliza o jogo
        playSound(deathSound); // toca som de morte
        return gameOver(); // chama a fun√ß√£o gameOver e retorna (encerra ciclo)
      }
      // se ainda tem vidas, reseta a cobra para posi√ß√£o inicial (centro)
      const startX = Math.floor((canvas.width/2)/cell)*cell;
      const startY = Math.floor((canvas.height/2)/cell)*cell;
      snake = [ [startX, startY], [startX-cell, startY], [startX-2*cell, startY] ]; // reset cobra
      dir = [1,0]; // dire√ß√£o volta para a direita
      food = randomFood(); // gera nova comida
      // faz uma pausa maior antes de reiniciar o loop para dar tempo ao jogador
      setTimeout(snakeLoop, gameSpeed * 3);
      return; // retorna para interromper execu√ß√£o atual
    }

    // adiciona nova cabe√ßa ao in√≠cio do array (movimento)
    snake.unshift(head);

    // se a cabe√ßa est√° sobre a comida, aumenta pontua√ß√£o e toca som; sen√£o, remove a cauda
    if(head[0] === food[0] && head[1] === food[1]){
      score += 10; // incrementa pontua√ß√£o
      playSound(eatSound); // toca som de comer
      food = randomFood(); // gera nova comida
    } else {
      snake.pop(); // remove o √∫ltimo segmento (a cobra "anda" sem crescer)
    }

    // ==================== DESENHAR COMIDA (MA√á√É) ====================
    ctx.beginPath(); // inicia caminho para a ma√ß√£ (c√≠rculo)
    ctx.fillStyle = '#e74c3c'; // cor de preenchimento vermelha
    // desenha um c√≠rculo preenchido para representar a ma√ß√£ (centralizada na c√©lula)
    ctx.arc(food[0] + cell/2, food[1] + cell/2, cell/2 - 2, 0, Math.PI*2);
    ctx.fill(); // preenche o c√≠rculo
    ctx.strokeStyle = '#c0392b'; // cor da borda da ma√ß√£
    ctx.stroke(); // aplica o tra√ßo ao redor da ma√ß√£

    ctx.beginPath(); // inicia caminho para o caule da ma√ß√£
    ctx.strokeStyle = '#6f4a2a'; // cor marrom para o caule
    ctx.lineWidth = 2; // largura do tra√ßo do caule
    ctx.moveTo(food[0] + cell/2, food[1] + 4); // posi√ß√£o de in√≠cio do caule (pr√≥xima ao centro)
    ctx.lineTo(food[0] + cell/2, food[1] - 6); // fim do caule (um pouco acima)
    ctx.stroke(); // aplica o tra√ßo do caule

    ctx.beginPath(); // inicia caminho para a folha da ma√ß√£
    ctx.fillStyle = '#27ae60'; // cor verde para a folha
    // desenha uma elipse inclinada para representar a folha
    ctx.ellipse(food[0] + cell/2 + 6, food[1] - 4, 5, 7, Math.PI/4, 0, 2*Math.PI);
    ctx.fill(); // preenche a folha

    // ==================== DESENHAR COBRA ====================
    snake.forEach((seg, i) => { // para cada segmento da cobra (seg = [x,y], i = √≠ndice)
      const radius = (i === 0) ? cell/2 : cell/2 - 2; // cabe√ßa tem raio maior
      // cria um gradiente radial para dar volume ao segmento
      const grad = ctx.createRadialGradient(seg[0]+cell/2, seg[1]+cell/2, 3, seg[0]+cell/2, seg[1]+cell/2, radius);
      grad.addColorStop(0, '#aef0c8'); grad.addColorStop(0.6, '#58d68d'); grad.addColorStop(1, '#117a43');
      ctx.fillStyle = grad; // aplica o gradiente como preenchimento
      ctx.beginPath(); // inicia caminho de desenho do segmento
      ctx.arc(seg[0]+cell/2, seg[1]+cell/2, radius, 0, Math.PI*2); // desenha c√≠rculo do segmento
      ctx.fill(); // preenche o segmento com o gradiente
      if(i === 0){ drawHeadDetails(seg, dir); } // se for cabe√ßa, desenha olhos e l√≠ngua
    });

    // ==================== HUD (PONTUA√á√ÉO E VIDAS) ====================
    ctx.fillStyle = '#2c3e50'; // cor do texto da HUD
    ctx.font = '20px Arial'; // fonte usada na HUD
    ctx.fillText(`Score: ${score}`, 20, 30); // desenha a pontua√ß√£o no canto superior esquerdo
    ctx.fillText(`Lives: ${lives}`, canvas.width - 110, 30); // desenha as vidas no canto superior direito

    // agenda o pr√≥ximo ciclo do loop conforme a velocidade definida
    setTimeout(snakeLoop, gameSpeed);
  }

  // ==================== FUN√á√ÉO AUXILIAR: DESENHAR DETALHES DA CABE√áA ====================
  function drawHeadDetails(seg, dir){
    const cx = seg[0] + cell/2; // centro X do segmento (cabe√ßa)
    const cy = seg[1] + cell/2; // centro Y do segmento (cabe√ßa)
    let ox = 0, oy = 0; // offsets para deslocar olhos conforme a dire√ß√£o

    // ajusta offsets para posicionar olhos dependendo da dire√ß√£o da cobra
    if(dir[0] === 1){ ox = 6; oy = 6; } // olhando para a direita
    if(dir[0] === -1){ ox = -6; oy = 6; } // olhando para a esquerda
    if(dir[1] === -1){ ox = 0; oy = -8; } // olhando para cima
    if(dir[1] === 1){ ox = 0; oy = 10; } // olhando para baixo

    // desenha os olhos brancos (dois c√≠rculos pequenos)
    ctx.fillStyle = '#ffffff';
    ctx.beginPath(); ctx.arc(cx - 6 + ox, cy - 4 + oy, 3, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 6 + ox, cy - 4 + oy, 3, 0, Math.PI*2); ctx.fill();

    // desenha as pupilas (menores e pretas) posicionadas √† frente conforme a dire√ß√£o
    ctx.fillStyle = '#000000';
    const pupilForward = 2; // deslocamento da pupila para "olhar para frente"
    if(dir[0] === 1){ 
      // pupilas levemente deslocadas para a direita
      ctx.beginPath(); ctx.arc(cx - 6 + ox + pupilForward, cy - 4 + oy, 1.5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx + 6 + ox + pupilForward, cy - 4 + oy, 1.5, 0, Math.PI*2); ctx.fill();
    } else if(dir[0] === -1){
      // pupilas levemente deslocadas para a esquerda
      ctx.beginPath(); ctx.arc(cx - 6 + ox - pupilForward, cy - 4 + oy, 1.5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx + 6 + ox - pupilForward, cy - 4 + oy, 1.5, 0, Math.PI*2); ctx.fill();
    } else if(dir[1] === -1){
      // pupilas levemente deslocadas para cima
      ctx.beginPath(); ctx.arc(cx - 6 + ox, cy - 4 + oy - pupilForward, 1.5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx + 6 + ox, cy - 4 + oy - pupilForward, 1.5, 0, Math.PI*2); ctx.fill();
    } else {
      // pupilas levemente deslocadas para baixo (dire√ß√£o para baixo)
      ctx.beginPath(); ctx.arc(cx - 6 + ox, cy - 4 + oy + pupilForward, 1.5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx + 6 + ox, cy - 4 + oy + pupilForward, 1.5, 0, Math.PI*2); ctx.fill();
    }

    // desenha l√≠ngua intermitente (aparece em alguns frames para anima√ß√£o)
    if(frameCount % 15 < 6){ // condi√ß√£o que faz a l√≠ngua aparecer periodicamente
      ctx.strokeStyle = '#c0392b'; // cor da l√≠ngua
      ctx.lineWidth = 2; // espessura do tra√ßo da l√≠ngua
      const tx = cx + dir[0] * (cell/2 + 2); // posi√ß√£o X da ponta da l√≠ngua
      const ty = cy + dir[1] * (cell/2 + 2); // posi√ß√£o Y da ponta da l√≠ngua
      ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(tx, ty); ctx.stroke(); // linha da l√≠ngua

      ctx.beginPath();
      if(dir[0] !== 0){
        // desenha bifurca√ß√£o da l√≠ngua se a dire√ß√£o for horizontal
        ctx.moveTo(tx, ty); ctx.lineTo(tx + dir[0]*4, ty - 4);
        ctx.moveTo(tx, ty); ctx.lineTo(tx + dir[0]*4, ty + 4);
      } else {
        // desenha bifurca√ß√£o da l√≠ngua se a dire√ß√£o for vertical
        ctx.moveTo(tx, ty); ctx.lineTo(tx - 4, ty + dir[1]*4);
        ctx.moveTo(tx, ty); ctx.lineTo(tx + 4, ty + dir[1]*4);
      }
      ctx.stroke(); // aplica o tra√ßo das bifurca√ß√µes
    }
  }

  // ==================== GAME OVER ====================
  function gameOver(){
    try{ music.pause(); }catch(e){} // tenta pausar m√∫sica (se estiver tocando)
    playSound(deathSound); // toca som de morte
    // mostra overlay de Game Over com pontua√ß√£o final e bot√£o para voltar ao menu
    showOverlay(`
      <h2>üíÄ Game Over</h2>
      <p>Pontua√ß√£o final: ${score}</p>
      <button onclick="mainMenu()">Voltar ao Menu</button>
    `);
  }

  // ==================== CONTROLES DO JOGADOR (TECLADO) ====================
  // Escuta eventos de teclado para mudar dire√ß√£o da cobra
  document.addEventListener('keydown', e => {
    // seta dire√ß√£o para cima se tecla for ArrowUp e a cobra n√£o estiver se movendo verticalmente
    if(e.key === 'ArrowUp' && dir[1] === 0) dir = [0, -1];
    // seta dire√ß√£o para baixo se tecla for ArrowDown e a cobra n√£o estiver se movendo verticalmente
    if(e.key === 'ArrowDown' && dir[1] === 0) dir = [0, 1];
    // seta dire√ß√£o para esquerda se tecla for ArrowLeft e a cobra n√£o estiver se movendo horizontalmente
    if(e.key === 'ArrowLeft' && dir[0] === 0) dir = [-1, 0];
    // seta dire√ß√£o para direita se tecla for ArrowRight e a cobra n√£o estiver se movendo horizontalmente
    if(e.key === 'ArrowRight' && dir[0] === 0) dir = [1, 0];
  });

  function resizeCanvas() {
    const defaultSize = 600;
    const size = Math.min(window.innerWidth, window.innerHeight, defaultSize);
    canvas.width = size;
    canvas.height = size;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas(); // Initial call

  function draw() {
    const scaleX = canvas.width / 600;
    const scaleY = canvas.height / 600;
    const scale = Math.min(scaleX, scaleY);

    ctx.save();
    ctx.scale(scale, scale);

    drawGameElements();

    ctx.restore();
  }


  // ==================== INICIA MOSTRANDO O MENU PRINCIPAL AO CARREGAR A P√ÅGINA ====================
  mainMenu(); // chama fun√ß√£o que exibe o menu inicial
  </script>
</body>
</html>
