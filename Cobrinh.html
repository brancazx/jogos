<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Snake Game</title>
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: linear-gradient(135deg, #2c3e50, #3498db);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    canvas {
      background: #ecf0f1;
      border: 8px solid #2c3e50;
      border-radius: 12px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.4);
    }
    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      background: rgba(44,62,80,0.85);
      color: #fff;
      font-size: 24px;
    }
    button, select, label, input {
      margin: 10px;
      padding: 12px 28px;
      font-size: 18px;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      cursor: pointer;
    }
    button { background: #27ae60; color: #fff; transition: background 0.3s; }
    button:hover { background: #2ecc71; }
    select { background: #fff; color: #2c3e50; }
    label { font-weight: normal; padding: 0; margin: 6px; }
    input[type="checkbox"]{ width:18px; height:18px; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="600" height="600"></canvas>
  <div id="overlay"></div>

  <script>
  // ==================== VARI√ÅVEIS GLOBAIS ====================
  const canvas = document.getElementById('gameCanvas'); // refer√™ncia ao canvas
  const ctx = canvas.getContext('2d'); // contexto 2D para desenhar
  const overlay = document.getElementById('overlay'); // div de menus

  let snake, dir, food, score, lives; // estado do jogo
  let cell = 20; // tamanho da c√©lula
  let gameSpeed = 100; // velocidade padr√£o (m√©dio)
  let mapSize = 600; // tamanho padr√£o do mapa
  let frameCount = 0; // contador de frames para anima√ß√µes

  // ====== SONS (configura√ß√£o mais robusta) ======
  // IMPORTANTE: os arquivos Musica.mp3, Maca.mp3 e Morte.mp3 devem estar
  // no mesmo diret√≥rio que este arquivo HTML (e com exatamente esses nomes,
  // respeitando mai√∫sculas/min√∫sculas). Renomeie se necess√°rio.
  const music = new Audio('Musica.mp3'); // trilha de fundo
  music.loop = true; // em loop
  music.preload = 'auto';
  music.volume = 0.5; // volume inicial (0.0 - 1.0)

  const eatSound = new Audio('Maca.mp3'); // som ao comer a ma√ß√£
  eatSound.preload = 'auto';
  eatSound.volume = 0.9;

  const deathSound = new Audio('Morte.mp3'); // som de morte
  deathSound.preload = 'auto';
  deathSound.volume = 0.9;

  // flag para controlar se efeitos sonoros/m√∫sica est√£o habilitados
  let soundEnabled = true;

  // Fun√ß√£o que tenta tocar a m√∫sica e faz fallback caso o navegador bloqueie autoplay
  function tryPlayMusic(){
    if(!soundEnabled) return; // se som desabilitado, n√£o tentar
    // play() retorna uma Promise ‚Äî navegadores modernos podem rejeitar se n√£o houver intera√ß√£o do usu√°rio
    music.play().then(()=>{
      // m√∫sica come√ßou com sucesso
      console.log('M√∫sica tocando');
    }).catch(err=>{
      // reprodu√ß√£o autom√°tica foi bloqueada. Criamos um bot√£o discreto para ativar o som via clique do usu√°rio.
      console.warn('Reprodu√ß√£o autom√°tica bloqueada pelo navegador:', err);
      showEnableSoundButton();
    });
  }

  function showEnableSoundButton(){
    // cria um bot√£o pequeno no canto para ativar o som
    const btnId = 'enable-sound-btn';
    if(document.getElementById(btnId)) return; // j√° existe
    const btn = document.createElement('button');
    btn.id = btnId;
    btn.textContent = 'Ativar Som';
    // estilo simples para ficar vis√≠vel mas discreto
    btn.style.position = 'absolute';
    btn.style.right = '16px';
    btn.style.top = '16px';
    btn.style.padding = '8px 12px';
    btn.style.fontSize = '14px';
    document.body.appendChild(btn);
    btn.addEventListener('click', ()=>{
      music.play().then(()=>{
        // remove o bot√£o quando o som come√ßar
        btn.remove();
      }).catch(e=>{
        console.error('Erro ao tentar tocar m√∫sica ap√≥s clique:', e);
      });
    });
  }

  // Fun√ß√£o utilit√°ria para tocar efeitos com tratamento de promessa
  function playSound(sound){
    if(!soundEnabled) return; // n√£o toca se som desabilitado
    // algumas vezes o mesmo Audio n√£o reinicia se estiver no meio de reprodu√ß√£o
    // definimos currentTime = 0 para reiniciar
    try{
      sound.currentTime = 0; // reinicia √°udio
    }catch(e){}
    sound.play().catch(err=>{
      // ignora erros de reprodu√ß√£o (por exemplo, se navegador bloquear sons)
      console.warn('Erro ao reproduzir som:', err);
    });
  }

  // ======== FUN√á√ïES DE MENU ========
  function showOverlay(html){ overlay.innerHTML=html; overlay.style.display='flex'; }
  function hideOverlay(){ overlay.style.display='none'; }

  function mainMenu(){
    // ao voltar para o menu, paramos a m√∫sica para n√£o ficar tocando em segundo plano
    try{ music.pause(); music.currentTime = 0; }catch(e){}

    // menu principal com bot√£o START e link para op√ß√µes
    showOverlay(`
      <h1>üêç Snake Game</h1>
      <button onclick="startSnake()">START</button>
      <button onclick="optionsMenu()">Op√ß√µes</button>
    `);
  }

  function optionsMenu(){
    // mostra op√ß√µes: dificuldade, tamanho do mapa e controlar som
    showOverlay(`
      <h2>‚öôÔ∏è Op√ß√µes</h2>
      <div style="display:flex;flex-direction:column;align-items:center;">
        <label for="difficulty">Dificuldade (velocidade)</label>
        <select id="difficulty">
          <option value="120">F√°cil</option>
          <option value="100" selected>M√©dio</option>
          <option value="60">Dif√≠cil</option>
        </select>

        <label for="mapSize">Tamanho do mapa</label>
        <select id="mapSize">
          <option value="400">Pequeno</option>
          <option value="600" selected>M√©dio</option>
          <option value="800">Grande</option>
        </select>

        <div style="margin-top:10px; display:flex; align-items:center; gap:8px;">
          <input type="checkbox" id="soundOn" checked />
          <label for="soundOn">Som ativado</label>
        </div>

        <div style="margin-top:12px;">
          <button onclick="applyOptions()">Salvar</button>
          <button onclick="mainMenu()">Voltar</button>
        </div>
      </div>
    `);
  }

  function applyOptions(){
    // l√™ op√ß√µes e aplica
    const diff = document.getElementById('difficulty').value;
    const size = document.getElementById('mapSize').value;
    const soundOnCheckbox = document.getElementById('soundOn');

    gameSpeed = parseInt(diff);
    mapSize = parseInt(size);
    soundEnabled = !!soundOnCheckbox.checked;

    // aplica tamanho do canvas
    canvas.width = mapSize;
    canvas.height = mapSize;

    // se som foi desativado, pausamos tudo
    if(!soundEnabled){
      try{ music.pause(); }catch(e){}
    }

    mainMenu();
  }

  // ======== INICIO DO JOGO ========
  function startSnake(){
    hideOverlay();

    // inicializa estado da cobra no centro (ajuste simples)
    const startX = Math.floor((canvas.width/2)/cell)*cell;
    const startY = Math.floor((canvas.height/2)/cell)*cell;
    snake = [ [startX, startY], [startX-cell, startY], [startX-2*cell, startY] ];
    dir = [1,0];

    // inicializa comida, pontos e vidas
    food = randomFood();
    score = 0;
    lives = 3;
    frameCount = 0;

    // tenta tocar m√∫sica (pode ser bloqueada pelo navegador)
    tryPlayMusic();

    // inicia loop do jogo
    snakeLoop();
  }

  // ======== GERAR COMIDA ========
  function randomFood(){
    // gera posi√ß√£o alinhada ao grid, evitando a posi√ß√£o atual da cobra
    let fx, fy;
    do{
      fx = Math.floor(Math.random()*(canvas.width/cell))*cell;
      fy = Math.floor(Math.random()*(canvas.height/cell))*cell;
      // continua gerando enquanto estiver em cima de um segmento da cobra
    } while(snake.some(seg=>seg[0]===fx && seg[1]===fy));
    return [fx, fy];
  }

  // ======== LOOP PRINCIPAL ========
  function snakeLoop(){
    // limpa a tela
    ctx.clearRect(0,0,canvas.width,canvas.height);
    frameCount++;

    // desenha grid de fundo (est√©tico)
    ctx.strokeStyle = '#e1e5e9';
    for(let x=0;x<canvas.width;x+=cell){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
    for(let y=0;y<canvas.height;y+=cell){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }

    // calcula nova cabe√ßa com base na dire√ß√£o atual
    const head = [snake[0][0] + dir[0]*cell, snake[0][1] + dir[1]*cell];

    // verifica colis√µes com parede ou com o pr√≥prio corpo
    const hitWall = head[0] < 0 || head[1] < 0 || head[0] >= canvas.width || head[1] >= canvas.height;
    const hitSelf = snake.some(seg => seg[0] === head[0] && seg[1] === head[1]);
    if(hitWall || hitSelf){
      lives -= 1; // perde uma vida
      if(lives <= 0){
        // toca som de morte (tratado) e finaliza
        playSound(deathSound);
        return gameOver();
      }
      // reseta cobra para posi√ß√£o inicial e pausa curta
      const startX = Math.floor((canvas.width/2)/cell)*cell;
      const startY = Math.floor((canvas.height/2)/cell)*cell;
      snake = [ [startX, startY], [startX-cell, startY], [startX-2*cell, startY] ];
      dir = [1,0];
      food = randomFood();
      setTimeout(snakeLoop, gameSpeed * 3);
      return;
    }

    // move a cobra (adiciona nova cabe√ßa)
    snake.unshift(head);

    // verifica se comeu a ma√ß√£
    if(head[0] === food[0] && head[1] === food[1]){
      score += 10; // pontua√ß√£o
      playSound(eatSound); // som de comer (tratado)
      food = randomFood(); // nova comida
    } else {
      // remove o √∫ltimo segmento (movimento normal)
      snake.pop();
    }

    // ======== DESENHAR MA√á√É ========
    // corpo da ma√ß√£
    ctx.beginPath();
    ctx.fillStyle = '#e74c3c';
    ctx.arc(food[0] + cell/2, food[1] + cell/2, cell/2 - 2, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#c0392b';
    ctx.stroke();
    // caule
    ctx.beginPath();
    ctx.strokeStyle = '#6f4a2a';
    ctx.lineWidth = 2;
    ctx.moveTo(food[0] + cell/2, food[1] + 4);
    ctx.lineTo(food[0] + cell/2, food[1] - 6);
    ctx.stroke();
    // folha
    ctx.beginPath();
    ctx.fillStyle = '#27ae60';
    ctx.ellipse(food[0] + cell/2 + 6, food[1] - 4, 5, 7, Math.PI/4, 0, 2*Math.PI);
    ctx.fill();

    // ======== DESENHAR COBRA (segments) ========
    snake.forEach((seg, i) => {
      // cabe√ßa ligeiramente maior
      const radius = (i === 0) ? cell/2 : cell/2 - 2;

      // gradiente radial para efeito 3D no segmento
      const grad = ctx.createRadialGradient(seg[0]+cell/2, seg[1]+cell/2, 3, seg[0]+cell/2, seg[1]+cell/2, radius);
      // varia√ß√£o de cor para dar boa leitura
      grad.addColorStop(0, '#aef0c8');
      grad.addColorStop(0.6, '#58d68d');
      grad.addColorStop(1, '#117a43');
      ctx.fillStyle = grad;

      // desenha segmento como c√≠rculo
      ctx.beginPath();
      ctx.arc(seg[0]+cell/2, seg[1]+cell/2, radius, 0, Math.PI*2);
      ctx.fill();

      // se for cabe√ßa, desenhar olhos e l√≠ngua orientados pela dire√ß√£o
      if(i === 0){
        drawHeadDetails(seg, dir);
      }
    });

    // ======== HUD ========
    ctx.fillStyle = '#2c3e50';
    ctx.font = '20px Arial';
    ctx.fillText(`Score: ${score}`, 20, 30);
    ctx.fillText(`Lives: ${lives}`, canvas.width - 110, 30);

    // agenda pr√≥ximo frame
    setTimeout(snakeLoop, gameSpeed);
  }

  // desenha olhos e l√≠ngua orientados pela dire√ß√£o
  function drawHeadDetails(seg, dir){
    // posi√ß√£o central do segmento (cabe√ßa)
    const cx = seg[0] + cell/2;
    const cy = seg[1] + cell/2;

    // offsets dos olhos dependendo da dire√ß√£o
    let ox = 0; // offset horizontal para olhos
    let oy = 0; // offset vertical para olhos
    // olhos s√£o posicionados levemente para frente/para os lados
    if(dir[0] === 1){ ox = 6; oy = 6; } // direita
    if(dir[0] === -1){ ox = -6; oy = 6; } // esquerda
    if(dir[1] === -1){ ox = 0; oy = -8; } // cima (olhos acima)
    if(dir[1] === 1){ ox = 0; oy = 10; } // baixo (olhos abaixo)

    // desenha olhos (branco)
    ctx.fillStyle = '#ffffff';
    // olho esquerdo
    ctx.beginPath();
    ctx.arc(cx - 6 + ox, cy - 4 + oy, 3, 0, Math.PI*2);
    ctx.fill();
    // olho direito
    ctx.beginPath();
    ctx.arc(cx + 6 + ox, cy - 4 + oy, 3, 0, Math.PI*2);
    ctx.fill();

    // desenha pupilas pretas menores, posicionadas mais para frente
    ctx.fillStyle = '#000000';
    const pupilForward = 2; // empurra pupila para frente
    if(dir[0] === 1){ // direita
      ctx.beginPath(); ctx.arc(cx - 6 + ox + pupilForward, cy - 4 + oy, 1.5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx + 6 + ox + pupilForward, cy - 4 + oy, 1.5, 0, Math.PI*2); ctx.fill();
    } else if(dir[0] === -1){ // esquerda
      ctx.beginPath(); ctx.arc(cx - 6 + ox - pupilForward, cy - 4 + oy, 1.5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx + 6 + ox - pupilForward, cy - 4 + oy, 1.5, 0, Math.PI*2); ctx.fill();
    } else if(dir[1] === -1){ // cima
      ctx.beginPath(); ctx.arc(cx - 6 + ox, cy - 4 + oy - pupilForward, 1.5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx + 6 + ox, cy - 4 + oy - pupilForward, 1.5, 0, Math.PI*2); ctx.fill();
    } else { // baixo ou padr√£o
      ctx.beginPath(); ctx.arc(cx - 6 + ox, cy - 4 + oy + pupilForward, 1.5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx + 6 + ox, cy - 4 + oy + pupilForward, 1.5, 0, Math.PI*2); ctx.fill();
    }

    // l√≠ngua bifurcada que aparece intermitentemente, apontando para a frente
    if(frameCount % 15 < 6){
      ctx.strokeStyle = '#c0392b';
      ctx.lineWidth = 2;
      ctx.beginPath();
      // ponta da l√≠ngua um pouco √† frente da cabe√ßa
      const tx = cx + dir[0] * (cell/2 + 2);
      const ty = cy + dir[1] * (cell/2 + 2);
      // linha principal
      ctx.moveTo(cx, cy);
      ctx.lineTo(tx, ty);
      ctx.stroke();

      // bifurca√ß√£o: duas pequenas pontas
      ctx.beginPath();
      if(dir[0] !== 0){
        // se horizontal, bifurcar para cima/baixo
        ctx.moveTo(tx, ty);
        ctx.lineTo(tx + dir[0]*4, ty - 4);
        ctx.moveTo(tx, ty);
        ctx.lineTo(tx + dir[0]*4, ty + 4);
      } else {
        // se vertical, bifurcar esquerda/direita
        ctx.moveTo(tx, ty);
        ctx.lineTo(tx - 4, ty + dir[1]*4);
        ctx.moveTo(tx, ty);
        ctx.lineTo(tx + 4, ty + dir[1]*4);
      }
      ctx.stroke();
    }
  }

  // ======== GAME OVER ========
  function gameOver(){
    // pausa m√∫sica no game over para evitar tocar em segundo plano
    try{ music.pause(); }catch(e){}
    playSound(deathSound);
    showOverlay(`
      <h2>üíÄ Game Over</h2>
      <p>Pontua√ß√£o final: ${score}</p>
      <button onclick="mainMenu()">Voltar ao Menu</button>
    `);
  }

  // ======== CONTROLES ========
  document.addEventListener('keydown', e => {
    // evita revers√£o direta (por exemplo, ir para esquerda quando movendo para a direita)
    if(e.key === 'ArrowUp' && dir[1] === 0) dir = [0, -1];
    if(e.key === 'ArrowDown' && dir[1] === 0) dir = [0, 1];
    if(e.key === 'ArrowLeft' && dir[0] === 0) dir = [-1, 0];
    if(e.key === 'ArrowRight' && dir[0] === 0) dir = [1, 0];
  });

  // ======== INICIA JOGO EXIBINDO MENU ========
  mainMenu();

  </script>
</body>
</html>